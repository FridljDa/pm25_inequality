---
title: "scratch"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
replace_values <- function(df, findreplace) {
  cat("Find and Replace\n")
  ##--doing some filtering on findreplace---
  findreplace <- findreplace %>% 
    filter(replacecolumns %in% colnames(df))
  
  findreplace_replacecolumns_unique <- unique(findreplace$replacecolumns)
  
  # Go through each unique column
  filtered_findreplace <- purrr::map_dfr(findreplace_replacecolumns_unique, function(column) {
    findreplace %>% 
      filter(replacecolumns == column, from %in% as.character(df[[column]]))
  })
  
  findreplace <- filtered_findreplace
  
  ###--- do some type conversion---
  # Create a new column with can_be_numeric result
  findreplace <- findreplace %>% 
    mutate(to_can_be_numeric = sapply(to, can_be_numeric))
  
  # Split the data frame
  findreplace_split <- split(findreplace, findreplace$replacecolumns)
  
  # Iterate over each group
  for (column in names(findreplace_split)) {
    # Check if there is any row where `can_be_numeric_to` is `FALSE`
    if (any(!findreplace_split_column$can_be_numeric_to) & is.numeric(df[[column]])) {
      df[[column]] <- as.character(df[[column]])
    }
  }
  
  #---- Initialize a logical matrix to track replacements-----
  replacement_matrix <- matrix(FALSE, nrow(df), length(unique(findreplace_replacecolumns_unique)))
  colnames(replacement_matrix) <- findreplace_replacecolumns_unique
  
  df <- as.data.frame(df)
  df_copy <- df
  
  # Add progress bar for the loop
  pb <- progress::progress_bar$new(format = "[:bar] :percent ETA: :eta", total = nrow(findreplace))
  
  # Replacing values
  for (i in seq_len(nrow(findreplace))) {
    column <- findreplace$replacecolumns[i]
    from <- findreplace$from[i]
    to <- findreplace$to[i]
    
    replaced_indices <- ifelse(is.na(from), is.na(df[[column]]), df[[column]] == from)
    
    #if (sum(replaced_indices, na.rm = TRUE) > 0) { 
      df[replaced_indices, column] <- to
      replacement_matrix[replaced_indices, column] <- TRUE
    #}
    
    # Update the progress bar
    pb$tick()
  }
  
  # Print values that were not replaced for each column
  if (any(!replacement_matrix)) {
    cat("\nValues not replaced:\n")
    for (col in findreplace_replacecolumns_unique) {
      not_replaced <- df_copy[!replacement_matrix[, col], col]
      if (length(not_replaced) > 0) {
        cat("Column:", col, "\n")
        print(not_replaced)
      }
    }
  }
  
  return(df)
}

```

The `echo: false` option disables the printing of code (only output is displayed).

```{r}
replace_values <- function(df, findreplace) {
  cat("Find and Replace\n")
  
  findreplace_replacecolumns_unique <- unique(findreplace$replacecolumns)
  
  # Split the data frame
  findreplace_split <- split(findreplace, findreplace$replacecolumns)
  
  
  # Replacing values
  for (i in seq_len(nrow(findreplace))) {
    column <- findreplace$replacecolumns[i]
    from <- findreplace$from[i]
    to <- findreplace$to[i]
    
    replaced_indices <- ifelse(is.na(from), is.na(df[[column]]), df[[column]] == from)
    
    #if (sum(replaced_indices, na.rm = TRUE) > 0) { 
      df[replaced_indices, column] <- to
      replacement_matrix[replaced_indices, column] <- TRUE
    #}
    
  }
  
  
  return(df)
}

```


```{r}
replace_values <- function(df, findreplace, NA_string = "Unique_NA_String") {
  
  # Check if findreplace contains duplicate combinations of replacecolumns and from
  if(any(duplicated(findreplace[, c("replacecolumns", "from")]))) {
    stop("Error: findreplace contains multiple rows with the same replacecolumns, from combination.")
  }
  
  # Replace NA values with the unique string in df and findreplace
  df <- replace(df, is.na(df), NA_string)
  findreplace <- replace(findreplace, is.na(findreplace), NA_string)
  
  # Pre-filter findreplace
  findreplace <- dplyr::filter(findreplace, replacecolumns %in% colnames(df))
  
  findreplace_replacecolumns_unique <- unique(findreplace$replacecolumns)
  
  # Go through each unique column
  filtered_findreplace <- purrr::map_dfr(findreplace_replacecolumns_unique, function(column) {
    dplyr::filter(findreplace, replacecolumns == column, from %in% as.character(df[[column]]))
  })
  
  findreplace <- filtered_findreplace

  # Split the data frame
  findreplace_split <- split(findreplace, findreplace$replacecolumns)
  
  # Initialize a vector to store values in vec that have no corresponding values in findreplace
  missing_values <- vector(mode = "list", length = length(findreplace_replacecolumns_unique))
  names(missing_values) <- findreplace_replacecolumns_unique
  
  # Replacing values
  for (column in findreplace_replacecolumns_unique) {
    findreplace_split_column <- findreplace_split[[column]]
    findreplace_split_column$replacecolumns <- NULL
    #findreplace_split_column <- dplyr::select(findreplace_split_column, -replacecolumns)
    # If df[[column]] is numeric and findreplace_split_column$from can be converted to numeric
    if (is.numeric(df[[column]]) && can_be_numeric(findreplace_split_column$from)) {
      findreplace_split_column$from <- as.numeric(findreplace_split_column$from)
    }
    # Convert df[[column]] to a character if it is not
    else if (any(!can_be_numeric(findreplace_split_column$from)) && !is.character(df[[column]])) {
      df[[column]] <- as.character(df[[column]])
    }
    
    # Perform the join
    by_vector <- setNames("from", column)
    #by_vector <- c("from" = column)
    
    #df <- findreplace_split_column %>%
    #  dplyr::right_join(df, by = by_vector)
    print(paste("findreplace_split_column: ",findreplace_split_column))
    browser()
    df <- df %>%
    dplyr::left_join(findreplace_split_column, by = by_vector)
    
    # Find values in vec that have no corresponding values in findreplace
    missing_values[[column]] <- df[is.na(df$to), column]
    
    # Replace vec column with to, then remove to column
    df <- df %>%
  dplyr::mutate_at(dplyr::vars(column), ~dplyr::coalesce(to, .))

    df <- df %>%
      dplyr::select(-to)
  }
  
  # Print values that were not replaced for each column
  cat("\nValues not replaced:\n")
  for (column in findreplace_replacecolumns_unique) {
    if (length(missing_values[[column]]) > 0) {
      cat("Column:", column, "\n")
      print(missing_values[[column]])
    }
  }

  # Convert columns that can be numeric to numeric
  for (column in colnames(df)) {
    if (can_be_numeric(df[[column]])) {
      df[[column]] <- as.numeric(df[[column]])
    }
  }
  
  # Convert the unique string back to NA
  df <- replace(df, df == NA_string, NA)
  
  return(df)
}

```

```{r}
#' Convert columns of a dataframe that can be numeric to numeric
#'
#' This function takes a dataframe as input and iterates over each column.
#' If a column can be converted to a numeric type, it performs the conversion.
#'
#' @param df A dataframe with the columns to convert.
#'
#' @return A dataframe with columns converted to numeric type if possible.
#'
#' @examples
#' # create a sample data frame
#' df <- data.frame(a = c("1", "2", "3"), b = c("a", "b", "c"))
#' df <- convert_columns_to_numeric(df)
#'
convert_columns_to_numeric <- function(df) {
  for (column in colnames(df)) {
    if (can_be_numeric(df[[column]])) {
      df[[column]] <- as.numeric(df[[column]])
    }
  }
  return(df)
}

```

```{r}
replace_values <- function(df, findreplace, NA_string = "Unique_NA_String") {
  
  # Check if findreplace contains duplicate combinations of replacecolumns and from
  if(any(duplicated(findreplace[, c("replacecolumns", "from")]))) {
    stop("Error: findreplace contains multiple rows with the same replacecolumns, from combination.")
  }
  
  #reduce everything
  df <- convert_columns_to_numeric(df) %>%
    dplyr::mutate(across(everything(), as.character))
  
  # Replace NA values with the unique string in df and findreplace
  df <- replace(df, is.na(df), NA_string)
  findreplace <- replace(findreplace, is.na(findreplace), NA_string)
  
  # Pre-filter findreplace
  findreplace <- dplyr::filter(findreplace, replacecolumns %in% colnames(df))
    
  for (replacecolumn in unique(findreplace$replacecolumns)) {
    #if (replacecolumn %in% colnames(df)) {
      findreplace_column <- dplyr::filter(findreplace, replacecolumns == replacecolumn) %>%
        dplyr::mutate(replacecolumns = NULL) 
      
      #reduce everything
  findreplace_column <- convert_columns_to_numeric(findreplace_column) %>%
    dplyr::mutate(across(everything(), as.character))
      
    # If df[[replacecolumn]] is numeric and findreplace_split_column$from can be converted to numeric
  
      replacement <- df %>%
        dplyr::select(all_of(replacecolumn)) %>%
        #dplyr::mutate(across(everything(), as.character)) %>%
        dplyr::left_join(findreplace_column,
                         by = setNames("from", replacecolumn))
      
      missing <- replacement %>%
        dplyr::filter(is.na(to)) %>%
        dplyr::distinct()
      
      if (nrow(missing) > 0) {
        print(paste("no value assigned in", replacecolumn, "for"))
        print(missing[, 1] %>% unique())
      }
      
      df[, replacecolumn] <- dplyr::coalesce(replacement$to, df[, replacecolumn])
      #df[, replacecolumn] <- replacement %>% dplyr::select(to)
    #}
  }
  
  # Convert the unique string back to NA
  df <- replace(df, df == NA_string, NA)
  df <- convert_columns_to_numeric(df)
  
  return(df)
}

```

```{r}
library(testthat)
test_that("Replacement of NA values is successful", {
  df <- data.frame(col1 = c(1, 2, NA, 4), col2 = c("a", "b", NA, "d"), stringsAsFactors = FALSE)
  findreplace <- data.frame(replacecolumns = c("col1", "col2"), from = c(NA, NA), to = c(666, "missing"), stringsAsFactors = FALSE)
  df_replaced <- replace_values(df, findreplace)
  
  expect_true(all(!is.na(df_replaced)))
  expect_equal(df_replaced$col1[3], 666)    # Expecting numeric value 666 instead of "missing"
  expect_equal(df_replaced$col2[3], "missing")
})
```


```{r}
library(testthat)
test_that("Replacement of NA values is successful", {
  df <- data.frame(col1 = c(1, 2, NA, 4), col2 = c("a", "b", NA, "d"), stringsAsFactors = FALSE)
  findreplace <- data.frame(replacecolumns = c("col1", "col2"), from = c(NA, NA), to = c(666, "missing"), stringsAsFactors = FALSE)
  df_replaced <- replace_values(df, findreplace)
  
  expect_true(all(!is.na(df_replaced)))
  expect_equal(df_replaced$col1[3], 666)    # Expecting numeric value 666 instead of "missing"
  expect_equal(df_replaced$col2[3], "missing")
})


test_that("Value replacement is successful", {
  df <- data.frame(col1 = c(1, 2, 3, 4), col2 = c("a", "b", "c", "d"), stringsAsFactors = FALSE)
  findreplace <- data.frame(replacecolumns = c("col1", "col2"), from = c(1, "a"), to = c(100, "z"), stringsAsFactors = FALSE)
  df <- replace_values(df, findreplace)
  
  expect_equal(df$col1[1], 100)
  expect_equal(df$col2[1], "z")
})

test_that("No replacement when 'from' value is not in the column", {
  df <- data.frame(col1 = c(1, 2, 3, 4), col2 = c("a", "b", "c", "d"), stringsAsFactors = FALSE)
  findreplace <- data.frame(replacecolumns = c("col1", "col2"), from = c(100, "z"), to = c(1000, "zz"), stringsAsFactors = FALSE)
  df <- replace_values(df, findreplace)
  
  expect_equal(df$col1[1], 1)  # unchanged
  expect_equal(df$col2[1], "a")  # unchanged
})


```
```{r}
# Load the required libraries
library(testthat)


# Define the unit test
test_that("replace_values function works correctly with larger data and more edge cases", {
  # Create the original dataframe
  df <- data.frame(
    col1 = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    col2 = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"),
    col3 = c(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5),
    col4 = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE),
    stringsAsFactors = FALSE
  )
  
  # Define the findreplace dataframe with more edge cases
  findreplace <- data.frame(
    replacecolumns = c("col1", "col2", "col3", "col4"),
    from = c(1, "a", 3.5, FALSE),
    to = c(100, "z", 999, TRUE),
    stringsAsFactors = FALSE
  )
  
  # Apply the replace_values function
  df <- replace_values(df, findreplace)
  
  # Test the results
  expect_equal(df$col1[1], 100)
  expect_equal(df$col2[1], "z")
  expect_equal(df$col3[3], 999)
  #expect_equal(df$col4[4], TRUE)
  
  # Check if other values remain unchanged
  expect_equal(df$col1[2], 2)
  expect_equal(df$col2[2], "b")
  expect_equal(df$col3[4], 4.5)
  #expect_equal(df$col4[1], TRUE)
  expect_equal(df$col1[10], 10)
  expect_equal(df$col2[10], "j")
  expect_equal(df$col3[6], 6.5)
  #expect_equal(df$col4[6], FALSE)
  
  # Check if non-existing values are not affected
  expect_equal(df$col1[5], 5)
  expect_equal(df$col2[5], "e")
  expect_equal(df$col3[9], 9.5)
  #expect_equal(df$col4[8], FALSE)
})

```

